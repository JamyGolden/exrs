use crate::image::*;
use crate::meta::header::{Header};
use crate::error::{Result, UnitResult};
use crate::block::lines::LineRef;
use crate::math::Vec2;
use crate::meta::attribute::{ChannelInfo, SampleType};
use crate::image::read::any_channels::{SamplesReader, ReadSamples};
use crate::image::read::levels::{ReadSamplesLevel, ReadAllLevels, ReadLargestLevel};
use crate::block::chunk::TileCoordinates;
// use crate::image::read::layers::ReadChannels;

// FIXME do not throw error on deep data but just skip it!
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct ReadFlatSamples;
// pub struct ReadAnySamples;

impl ReadFlatSamples {

    // TODO
    // e. g. `let sum = reader.any_channels_with(|sample, sum| sum += sample)`
    // pub fn any_channels_with <S> (self, storage: S) -> {  }


    pub fn largest_resolution_level(self) -> ReadLargestLevel<Self> { ReadLargestLevel { read_samples: self } }
    pub fn all_resolution_levels(self) -> ReadAllLevels<Self> { ReadAllLevels { read_samples: self } }
}


/*pub struct AnySamplesReader {
    resolution: Vec2<usize>,
    samples: DeepAndFlatSamples
}*/

/// No deep data.
#[derive(Debug, Clone, PartialEq)]
pub struct FlatSamplesReader {
    resolution: Vec2<usize>,
    samples: FlatSamples
}



impl ReadSamples for ReadFlatSamples {
    type Reader = FlatSamplesReader;

    fn create_sample_reader(&self, header: &Header, channel: &ChannelInfo) -> Result<Self::Reader> {
        self.create_samples_level_reader(header, channel, header.layer_size)
    }
}

impl ReadSamplesLevel for ReadFlatSamples {
    type Reader = FlatSamplesReader;

    fn create_samples_level_reader(&self, header: &Header, channel: &ChannelInfo, size: Vec2<usize>) -> Result<Self::Reader> {
        Ok(FlatSamplesReader {
            resolution: header.layer_size, // TODO sub sampling
            samples: match channel.sample_type {
                SampleType::F16 => FlatSamples::F16(vec![f16::ZERO; size.area()]),
                SampleType::F32 => FlatSamples::F32(vec![0.0; size.area()]),
                SampleType::U32 => FlatSamples::U32(vec![0; size.area()]),
            }
        })
    }
}


// TODO impl SamplesReader for AnySamples { }

impl SamplesReader for FlatSamplesReader {
    type Samples = FlatSamples;

    fn read_line(&mut self, line: LineRef<'_>) -> UnitResult {
        let index = line.location;
        let resolution = self.resolution;

        // the index is generated by ourselves and must always be correct
        debug_assert!(index.position.x() + index.sample_count <= resolution.width(), "line index calculation bug");
        debug_assert!(index.position.y() < resolution.height(), "line index calculation bug");
        debug_assert_ne!(resolution.0, 0, "sample size bug");

        let start_index = index.position.y() * resolution.width() + index.position.x();
        let end_index = start_index + index.sample_count;
        debug_assert!(start_index < end_index && end_index <= self.samples.len(), "line {:?} is invalid", line);


        match &mut self.samples {
            FlatSamples::F16(samples) =>
                line.read_samples_into_slice(&mut samples[start_index .. end_index])
                    .expect("writing line bytes failed"),

            FlatSamples::F32(samples) =>
                line.read_samples_into_slice(&mut samples[start_index .. end_index])
                    .expect("writing line bytes failed"),

            FlatSamples::U32(samples) =>
                line.read_samples_into_slice(&mut samples[start_index .. end_index])
                    .expect("writing line bytes failed"),
        }

        Ok(())
    }

    fn filter_block(&self, (_, tile): (usize, &TileCoordinates)) -> bool {
        tile.is_largest_resolution_level()
    }

    fn into_samples(self) -> FlatSamples {
        self.samples
    }
}

